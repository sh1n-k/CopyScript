--- START OF FILE: clipboard_monitor.py ---
```
"""클립보드 모니터링 모듈 (YouTube URL 감지 → 자막을 클립보드로 복사)"""

from __future__ import annotations

from collections import OrderedDict
from typing import Callable, Optional

import pyperclip

from subtitle_fetcher import SubtitleFetcher
from notifier import Notifier
from url_parser import extract_video_id


StatusCallback = Callable[[str, bool], None]


class ClipboardMonitor:
    """클립보드를 확인하고 YouTube URL이면 자막을 복사합니다.

    - 동시 실행 방지(락)
    - 동일 video_id 중복 처리 방지(LRU 캐시)
    """

    def __init__(
        self,
        fetcher: SubtitleFetcher,
        on_status_change: Optional[StatusCallback] = None,
        notifier: Optional[Notifier] = None,
        max_processed: int = 100,
    ):
        """
        Args:
            fetcher: SubtitleFetcher 인스턴스
            on_status_change: 상태 변경 콜백 (status: str, is_error: bool)
            notifier: Notifier 인스턴스 (선택)
            max_processed: 처리한 video_id LRU 캐시 최대 크기
        """
        self.fetcher = fetcher
        self.on_status_change = on_status_change
        self.notifier = notifier

        self._last_clipboard: str = ""
        self._max_processed = max(10, int(max_processed))

        # OrderedDict: insertion-ordered → LRU 흉내
        self._processed_ids: OrderedDict[str, None] = OrderedDict()

        # 재진입/동시 실행 방지용 플래그(락보다 가벼움)
        self._busy = False

    def _update_status(self, status: str, is_error: bool = False) -> None:
        """상태 업데이트 콜백 호출"""
        if self.on_status_change:
            try:
                self.on_status_change(status, is_error)
            except Exception:
                # GUI 종료 중 등 콜백 실패는 조용히 무시
                pass

    def _mark_processed(self, video_id: str) -> None:
        """LRU 캐시 갱신"""
        if video_id in self._processed_ids:
            self._processed_ids.move_to_end(video_id)
            return
        self._processed_ids[video_id] = None
        if len(self._processed_ids) > self._max_processed:
            # 가장 오래된 항목 제거
            self._processed_ids.popitem(last=False)

    def _notify(self, title: str, message: str) -> None:
        """알림 표시 (옵션)"""
        if self.notifier:
            self.notifier.notify(title, message)

    def check_and_process(self) -> bool:
        """
        클립보드를 확인하고 YouTube URL이면 자막을 복사합니다.

        Returns:
            처리 여부 (True: 자막 복사됨, False: 처리 안함)
        """
        current_video_id: Optional[str] = None
        if self._busy:
            return False

        self._busy = True
        try:
            try:
                current = pyperclip.paste()
            except Exception:
                # 클립보드 접근 실패 (환경/권한/툴 부재 등)
                self._update_status("클립보드 접근 실패", is_error=True)
                return False

            if not isinstance(current, str) or not current:
                return False

            if current == self._last_clipboard:
                return False

            self._last_clipboard = current

            current_video_id = extract_video_id(current)
            if not current_video_id:
                return False

            if current_video_id in self._processed_ids:
                status_msg = f"이미 처리됨: {current_video_id[:8]}..."
                self._update_status(status_msg)
                self._notify("이미 처리됨", f"{current_video_id}")
                # LRU 갱신
                self._processed_ids.move_to_end(current_video_id)
                return False

            self._update_status(f"자막 추출 중: {current_video_id}...")

            text, error = self.fetcher.fetch(current_video_id)

            if error:
                self._update_status(error, is_error=True)
                self._notify("자막 복사 실패", f"{current_video_id} - {error}")
                return False

            if not text:
                status_msg = "자막이 비어있습니다"
                self._update_status(status_msg, is_error=True)
                self._notify("자막 복사 실패", f"{current_video_id} - {status_msg}")
                return False

            # 클립보드에 자막 복사
            try:
                pyperclip.copy(text)
            except Exception:
                status_msg = "클립보드 복사 실패"
                self._update_status(status_msg, is_error=True)
                self._notify("자막 복사 실패", f"{current_video_id} - {status_msg}")
                return False

            # 방금 복사한 자막이 다시 감지되지 않도록
            self._last_clipboard = text

            self._mark_processed(current_video_id)

            line_count = text.count("\n") + 1
            status_msg = f"완료! {line_count}줄 복사됨"
            self._update_status(status_msg)

            self._notify("자막 복사 완료", f"{current_video_id} - {line_count}줄")

            return True

        except Exception as e:
            status_msg = f"오류: {str(e)}"
            self._update_status(status_msg, is_error=True)
            if current_video_id:
                self._notify("자막 복사 실패", f"{current_video_id} - {status_msg}")
            return False
        finally:
            self._busy = False

    def reset(self) -> None:
        """상태 초기화"""
        self._last_clipboard = ""
        self._busy = False

```
--- END OF FILE: clipboard_monitor.py ---


--- START OF FILE: clipboard_watchers.py ---
```
"""Windows/macOS 클립보드 변경 감지기.

- Windows: AddClipboardFormatListener + WM_CLIPBOARDUPDATE (진짜 이벤트 기반)
- macOS: NSPasteboard.changeCount (가벼운 폴링, 변경 시에만 처리)
"""

from __future__ import annotations

import platform
import queue
import threading
import time
from typing import Callable, Optional


class ClipboardWatcher:
    """플랫폼별 클립보드 변경 감지기.

    on_change는 "클립보드가 바뀌었다"는 신호만 전달해야 합니다.
    (무거운 작업은 on_change 내부에서 하더라도 watcher 이벤트 루프를 막지 않도록 설계)
    """

    def __init__(self, on_change: Callable[[], None]):
        self._on_change = on_change

    def start(self) -> None:
        raise NotImplementedError

    def stop(self) -> None:
        raise NotImplementedError


# ------------------------
# Windows: WM_CLIPBOARDUPDATE 이벤트 기반
# ------------------------
class WindowsClipboardWatcher(ClipboardWatcher):
    def __init__(self, on_change: Callable[[], None]):
        super().__init__(on_change)

        self._msg_thread: Optional[threading.Thread] = None
        self._worker_thread: Optional[threading.Thread] = None

        self._stop_event = threading.Event()
        self._hwnd = None
        self._wndproc = None
        self._class_name = "YTSubtitleClipboardListener"

        # 윈도우 메시지 핸들러(윈도우 스레드)에서 무거운 작업을 하면 안 됨 → 큐로 넘김
        self._q: "queue.Queue[int]" = queue.Queue()
        self._last_signal_ts = 0.0  # 간단 디바운스

    def start(self) -> None:
        if self._msg_thread and self._msg_thread.is_alive():
            return

        self._stop_event.clear()

        self._worker_thread = threading.Thread(target=self._worker_loop, daemon=True)
        self._worker_thread.start()

        self._msg_thread = threading.Thread(target=self._run_message_loop, daemon=True)
        self._msg_thread.start()

    def stop(self) -> None:
        self._stop_event.set()

        # 메시지 루프 깨우기
        try:
            import ctypes

            user32 = ctypes.windll.user32
            if self._hwnd:
                user32.PostMessageW(self._hwnd, 0x0012, 0, 0)  # WM_QUIT
        except Exception:
            pass

        if self._msg_thread:
            self._msg_thread.join(timeout=1.0)
        if self._worker_thread:
            self._worker_thread.join(timeout=1.0)

    def _worker_loop(self) -> None:
        while not self._stop_event.is_set():
            try:
                self._q.get(timeout=0.2)
            except queue.Empty:
                continue

            # 아주 짧은 디바운스(연속 이벤트 폭주 방지)
            now = time.monotonic()
            if now - self._last_signal_ts < 0.05:
                continue
            self._last_signal_ts = now

            try:
                self._on_change()
            except Exception:
                pass

    def _run_message_loop(self) -> None:
        import ctypes
        from ctypes import wintypes

        user32 = ctypes.windll.user32
        kernel32 = ctypes.windll.kernel32

        WM_CLIPBOARDUPDATE = 0x031D
        WM_DESTROY = 0x0002
        HWND_MESSAGE = wintypes.HWND(-3)

        WNDPROCTYPE = ctypes.WINFUNCTYPE(
            wintypes.LRESULT,
            wintypes.HWND,
            wintypes.UINT,
            wintypes.WPARAM,
            wintypes.LPARAM,
        )

        def _wnd_proc(hwnd, msg, wparam, lparam):
            if msg == WM_CLIPBOARDUPDATE:
                # 여기서 무거운 작업 금지 → 큐에 신호만
                try:
                    self._q.put_nowait(1)
                except Exception:
                    pass
                return 0

            if msg == WM_DESTROY:
                user32.PostQuitMessage(0)
                return 0

            return user32.DefWindowProcW(hwnd, msg, wparam, lparam)

        self._wndproc = WNDPROCTYPE(_wnd_proc)

        class WNDCLASS(ctypes.Structure):
            _fields_ = [
                ("style", wintypes.UINT),
                ("lpfnWndProc", WNDPROCTYPE),
                ("cbClsExtra", ctypes.c_int),
                ("cbWndExtra", ctypes.c_int),
                ("hInstance", wintypes.HINSTANCE),
                ("hIcon", wintypes.HICON),
                ("hCursor", wintypes.HCURSOR),
                ("hbrBackground", wintypes.HBRUSH),
                ("lpszMenuName", wintypes.LPCWSTR),
                ("lpszClassName", wintypes.LPCWSTR),
            ]

        hinst = kernel32.GetModuleHandleW(None)

        wndclass = WNDCLASS()
        wndclass.style = 0
        wndclass.lpfnWndProc = self._wndproc
        wndclass.cbClsExtra = 0
        wndclass.cbWndExtra = 0
        wndclass.hInstance = hinst
        wndclass.hIcon = None
        wndclass.hCursor = None
        wndclass.hbrBackground = None
        wndclass.lpszMenuName = None
        wndclass.lpszClassName = self._class_name

        # RegisterClassW는 실패해도(이미 등록됨 등) CreateWindow가 성공할 수 있음
        user32.RegisterClassW(ctypes.byref(wndclass))

        self._hwnd = user32.CreateWindowExW(
            0,
            self._class_name,
            self._class_name,
            0,
            0,
            0,
            0,
            0,
            HWND_MESSAGE,
            None,
            hinst,
            None,
        )
        if not self._hwnd:
            return

        if not user32.AddClipboardFormatListener(self._hwnd):
            return

        msg = wintypes.MSG()
        while not self._stop_event.is_set():
            ret = user32.GetMessageW(ctypes.byref(msg), 0, 0, 0)
            if ret == 0:  # WM_QUIT
                break
            if ret == -1:
                break
            user32.TranslateMessage(ctypes.byref(msg))
            user32.DispatchMessageW(ctypes.byref(msg))

        # cleanup
        try:
            user32.RemoveClipboardFormatListener(self._hwnd)
        except Exception:
            pass
        try:
            user32.DestroyWindow(self._hwnd)
        except Exception:
            pass

        self._hwnd = None


# ------------------------
# macOS: NSPasteboard.changeCount 기반(가벼운 폴링)
# ------------------------
class MacClipboardWatcher(ClipboardWatcher):
    def __init__(self, on_change: Callable[[], None], interval_sec: float = 0.25):
        super().__init__(on_change)
        self._interval = max(0.05, float(interval_sec))
        self._thread: Optional[threading.Thread] = None
        self._stop_event = threading.Event()

        self._last_signal_ts = 0.0  # 간단 디바운스

    def start(self) -> None:
        if self._thread and self._thread.is_alive():
            return
        self._stop_event.clear()
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self) -> None:
        self._stop_event.set()
        if self._thread:
            self._thread.join(timeout=1.0)

    def _run(self) -> None:
        try:
            from AppKit import NSPasteboard  # type: ignore
        except Exception:
            # pyobjc 미설치 시 동작 불가
            return

        pb = NSPasteboard.generalPasteboard()
        last = pb.changeCount()

        while not self._stop_event.is_set():
            time.sleep(self._interval)
            cur = pb.changeCount()
            if cur == last:
                continue
            last = cur

            # 디바운스
            now = time.monotonic()
            if now - self._last_signal_ts < 0.05:
                continue
            self._last_signal_ts = now

            try:
                self._on_change()
            except Exception:
                pass


def create_watcher(on_change: Callable[[], None]) -> ClipboardWatcher:
    system = platform.system()
    if system == "Windows":
        return WindowsClipboardWatcher(on_change)
    if system == "Darwin":
        return MacClipboardWatcher(on_change)
    raise RuntimeError("This app supports Windows/macOS only.")
```
--- END OF FILE: clipboard_watchers.py ---


--- START OF FILE: main.py ---
```
"""YouTube 자막 클립보드 복사 앱 - 메인 GUI"""

from __future__ import annotations

import tkinter as tk
from tkinter import ttk

from clipboard_monitor import ClipboardMonitor
from clipboard_watchers import create_watcher
from notifier import Notifier
from subtitle_fetcher import SubtitleFetcher, SUPPORTED_LANGUAGES


class App:
    """메인 애플리케이션 클래스"""

    def __init__(self):
        self.root = tk.Tk()
        self.root.title("YouTube 자막 복사")
        self.root.geometry("320x180")
        self.root.resizable(False, False)

        self.is_running = False
        self._closing = False

        # 자막 추출기, 알림, 모니터 초기화
        self.fetcher = SubtitleFetcher("ko")
        self.notifier = Notifier()
        self.monitor = ClipboardMonitor(self.fetcher, self._on_status_change, self.notifier)

        # 플랫폼별 감지기 (Windows=이벤트, macOS=changeCount)
        self.watcher = create_watcher(self._on_clipboard_change)

        self._setup_ui()
        self._center_window()

        self.root.protocol("WM_DELETE_WINDOW", self._on_close)

    def _setup_ui(self):
        """UI 구성"""
        main_frame = ttk.Frame(self.root, padding="15")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # 언어 선택
        lang_frame = ttk.Frame(main_frame)
        lang_frame.pack(fill=tk.X, pady=(0, 8))

        ttk.Label(lang_frame, text="언어:").pack(side=tk.LEFT)

        self.lang_var = tk.StringVar(value="ko")
        self.lang_combo = ttk.Combobox(
            lang_frame,
            textvariable=self.lang_var,
            values=[f"{name} ({code})" for name, code in SUPPORTED_LANGUAGES],
            state="readonly",
            width=18,
        )
        self.lang_combo.current(0)
        self.lang_combo.pack(side=tk.LEFT, padx=(10, 0))
        self.lang_combo.bind("<<ComboboxSelected>>", self._on_language_change)

        # 옵션: 타임스탬프
        option_frame = ttk.Frame(main_frame)
        option_frame.pack(fill=tk.X, pady=(0, 8))

        self.timestamp_var = tk.BooleanVar(value=False)
        self.timestamp_check = ttk.Checkbutton(
            option_frame,
            text="타임스탬프 포함 [00:00]",
            variable=self.timestamp_var,
            command=self._on_timestamp_change,
        )
        self.timestamp_check.pack(side=tk.LEFT)

        # 버튼
        btn_frame = ttk.Frame(main_frame)
        btn_frame.pack(fill=tk.X, pady=8)

        self.toggle_btn = ttk.Button(btn_frame, text="▶ 시작", command=self._toggle_monitor, width=12)
        self.toggle_btn.pack(side=tk.LEFT, padx=(0, 10))

        self.quit_btn = ttk.Button(btn_frame, text="종료", command=self._on_close, width=12)
        self.quit_btn.pack(side=tk.LEFT)

        # 상태 표시
        self.status_var = tk.StringVar(value="대기 중")
        self.status_label = ttk.Label(main_frame, textvariable=self.status_var, foreground="gray")
        self.status_label.pack(fill=tk.X, pady=(10, 0))

    def _center_window(self):
        """창을 화면 중앙에 배치"""
        self.root.update_idletasks()
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f"{width}x{height}+{x}+{y}")

    def _on_language_change(self, event=None):
        """언어 선택 변경 시"""
        selected = self.lang_combo.get()
        code = selected.split("(")[-1].rstrip(")")
        self.fetcher.set_language(code)
        self._update_status(f"언어 변경: {code}")

    def _on_timestamp_change(self):
        """타임스탬프 옵션 변경 시"""
        include = self.timestamp_var.get()
        self.fetcher.set_timestamp(include)
        status = "타임스탬프 포함" if include else "타임스탬프 제외"
        self._update_status(status)

    def _toggle_monitor(self):
        """모니터링 시작/정지 토글"""
        if self.is_running:
            self._stop_monitor()
        else:
            self._start_monitor()

    def _start_monitor(self):
        """모니터링 시작"""
        if self.is_running:
            return

        self.is_running = True
        self.monitor.reset()

        self.toggle_btn.config(text="⏹ 정지")
        self.lang_combo.config(state="disabled")
        self.timestamp_check.config(state="disabled")
        self._update_status("모니터링 중... (URL 복사 대기)")

        # 감지기 시작
        self.watcher.start()

    def _stop_monitor(self):
        """모니터링 정지"""
        if not self.is_running:
            return

        self.is_running = False

        # 감지기 정지(스레드 join 포함)
        self.watcher.stop()

        self.toggle_btn.config(text="▶ 시작")
        self.lang_combo.config(state="readonly")
        self.timestamp_check.config(state="normal")
        self._update_status("정지됨")

    def _on_clipboard_change(self) -> None:
        """Watcher 스레드에서 호출됨. 실제 처리는 monitor에서."""
        if not self.is_running or self._closing:
            return
        self.monitor.check_and_process()

    def _on_status_change(self, status: str, is_error: bool = False):
        """상태 변경 콜백 (스레드 안전)"""
        # destroy 이후 after 호출 방지
        if self._closing or not self.root.winfo_exists():
            return
        self.root.after(0, lambda: self._update_status(status, is_error))

    def _update_status(self, status: str, is_error: bool = False):
        """상태 라벨 업데이트"""
        self.status_var.set(status)
        color = "red" if is_error else ("green" if "완료" in status else "gray")
        self.status_label.config(foreground=color)

    def _on_close(self):
        """앱 종료"""
        if self._closing:
            return
        self._closing = True

        try:
            self._stop_monitor()
        finally:
            # after 큐에 남은 콜백이 있어도 _closing 가드가 막아줌
            self.root.destroy()

    def run(self):
        """앱 실행"""
        self.root.mainloop()


def main():
    App().run()


if __name__ == "__main__":
    main()
```
--- END OF FILE: main.py ---


--- START OF FILE: notifier.py ---
```
from __future__ import annotations
import platform
import subprocess
from dataclasses import dataclass


@dataclass
class Notifier:
    app_name: str = "YouTube 자막 복사"

    def notify(self, title: str, message: str) -> None:
        system = platform.system()
        if system == "Windows":
            self._notify_windows(title, message)
        elif system == "Darwin":
            self._notify_macos(title, message)
        else:
            # 요구사항 범위 밖(OS: Linux 등)에서는 조용히 무시
            return

    def _notify_windows(self, title: str, message: str) -> None:
        # win11toast는 Windows에서만 설치/사용하도록 지연 import
        try:
            from win11toast import toast  # type: ignore
        except Exception:
            # 패키지 미설치 등
            return
        try:
            # title, message 둘 다 지원
            toast(title, message)
        except Exception:
            # 알림 센터/집중 지원 등으로 표시되지 않을 수 있음
            return

    def _notify_macos(self, title: str, message: str) -> None:
        # osascript로 Notification Center 알림
        # 따옴표/역슬래시 이스케이프 처리
        safe_title = title.replace("\\", "\\\\").replace('"', '\\"')
        safe_msg = message.replace("\\", "\\\\").replace('"', '\\"')
        script = f'display notification "{safe_msg}" with title "{safe_title}"'
        try:
            subprocess.run(
                ["osascript", "-e", script], check=False, capture_output=True, text=True
            )
        except Exception:
            return

```
--- END OF FILE: notifier.py ---


--- START OF FILE: subtitle_fetcher.py ---
```
"""YouTube 자막 추출 모듈"""

from youtube_transcript_api import YouTubeTranscriptApi

# 지원 언어 목록 (표시명, 코드)
SUPPORTED_LANGUAGES = [
    ("한국어", "ko"),
    ("English", "en"),
    ("日本語", "ja"),
    ("中文", "zh-Hans"),
    ("Español", "es"),
    ("Français", "fr"),
    ("Deutsch", "de"),
    ("Auto (any)", "auto"),
]


def format_timestamp(seconds: float) -> str:
    """초를 MM:SS 또는 HH:MM:SS 형식으로 변환"""
    seconds = int(seconds)
    hours, remainder = divmod(seconds, 3600)
    minutes, secs = divmod(remainder, 60)
    if hours > 0:
        return f"{hours:02d}:{minutes:02d}:{secs:02d}"
    return f"{minutes:02d}:{secs:02d}"


class SubtitleFetcher:
    """YouTube 자막 추출 클래스"""

    def __init__(self, preferred_lang: str = "ko", include_timestamp: bool = False):
        self.preferred_lang = preferred_lang
        self.include_timestamp = include_timestamp
        self.api = YouTubeTranscriptApi()

    def set_language(self, lang_code: str):
        """선호 언어 설정"""
        self.preferred_lang = lang_code

    def set_timestamp(self, include: bool):
        """타임스탬프 포함 여부 설정"""
        self.include_timestamp = include

    def fetch(self, video_id: str) -> tuple[str, str | None]:
        """
        자막을 가져옵니다.

        탐색 순서:
        1. 선호 언어의 수동 자막
        2. 선호 언어의 자동생성 자막
        3. 다른 언어 자막을 선호 언어로 번역
        4. 아무 자막이나 (수동 우선)

        Args:
            video_id: YouTube video ID

        Returns:
            (자막 텍스트, 에러 메시지 또는 None)
        """
        try:
            transcript_list = self.api.list(video_id)

            transcript = None

            if self.preferred_lang == "auto":
                # 아무 자막이나 (수동 우선)
                transcript = self._get_any_transcript(transcript_list)
            else:
                # 1. 선호 언어 자막 (수동 + 자동생성 모두 검색)
                try:
                    transcript = transcript_list.find_transcript([self.preferred_lang])
                except Exception:
                    pass

                # 2. 다른 언어를 선호 언어로 번역
                if transcript is None:
                    transcript = self._try_translate(
                        transcript_list, self.preferred_lang
                    )

                # 3. 최후의 수단: 아무 자막이나
                if transcript is None:
                    transcript = self._get_any_transcript(transcript_list)

            if transcript is None:
                return "", "자막을 찾을 수 없습니다"

            # 자막 데이터 가져오기
            transcript_data = transcript.fetch()

            # 텍스트 추출 (타임스탬프 옵션에 따라)
            lines = []
            if hasattr(transcript_data, "snippets"):
                for snippet in transcript_data.snippets:
                    if self.include_timestamp:
                        ts = format_timestamp(snippet.start)
                        lines.append(f"[{ts}] {snippet.text}")
                    else:
                        lines.append(snippet.text)
            else:
                # 이전 버전 호환
                for entry in transcript_data:
                    if self.include_timestamp:
                        ts = format_timestamp(entry["start"])
                        lines.append(f"[{ts}] {entry['text']}")
                    else:
                        lines.append(entry["text"])

            full_text = "\n".join(lines)

            return full_text, None

        except Exception as e:
            error_str = str(e).lower()
            if "disabled" in error_str:
                return "", "자막이 비활성화된 영상입니다"
            elif "unavailable" in error_str:
                return "", "영상을 찾을 수 없습니다"
            elif "no transcript" in error_str:
                return "", "사용 가능한 자막이 없습니다"
            else:
                return "", f"오류: {str(e)}"

    def _get_any_transcript(self, transcript_list):
        """사용 가능한 아무 자막이나 반환 (수동 우선)"""
        # 수동 생성 자막 우선
        if transcript_list._manually_created_transcripts:
            return next(iter(transcript_list._manually_created_transcripts.values()))
        # 자동 생성 자막
        if transcript_list._generated_transcripts:
            return next(iter(transcript_list._generated_transcripts.values()))
        return None

    def _try_translate(self, transcript_list, target_lang: str):
        """번역 가능한 자막을 찾아 번역 시도"""
        # 자동 생성 자막은 보통 번역 가능
        for transcript in transcript_list:
            if transcript.is_translatable:
                try:
                    return transcript.translate(target_lang)
                except Exception:
                    continue
        return None


if __name__ == "__main__":
    # 테스트
    fetcher = SubtitleFetcher("ko")
    text, error = fetcher.fetch("dQw4w9WgXcQ")
    if error:
        print(f"Error: {error}")
    else:
        print(f"자막 길이: {len(text)} 글자")
        print(text[:500])

```
--- END OF FILE: subtitle_fetcher.py ---


--- START OF FILE: url_parser.py ---
```
"""YouTube URL 파싱 및 검증 모듈"""

import re
from urllib.parse import urlparse, parse_qs

# YouTube URL 패턴
YOUTUBE_PATTERNS = [
    r"(?:https?://)?(?:www\.)?youtube\.com/watch\?v=([a-zA-Z0-9_-]{11})",
    r"(?:https?://)?(?:www\.)?youtube\.com/embed/([a-zA-Z0-9_-]{11})",
    r"(?:https?://)?(?:www\.)?youtube\.com/v/([a-zA-Z0-9_-]{11})",
    r"(?:https?://)?youtu\.be/([a-zA-Z0-9_-]{11})",
    r"(?:https?://)?(?:www\.)?youtube\.com/shorts/([a-zA-Z0-9_-]{11})",
]


def extract_video_id(url: str) -> str | None:
    """
    YouTube URL에서 video_id를 추출합니다.

    Args:
        url: YouTube URL 문자열

    Returns:
        11자리 video_id 또는 None
    """
    if not url or not isinstance(url, str):
        return None

    url = url.strip()

    # 정규식 패턴 매칭
    for pattern in YOUTUBE_PATTERNS:
        match = re.search(pattern, url)
        if match:
            return match.group(1)

    # fallback: query parameter에서 v 추출
    try:
        parsed = urlparse(url)
        if "youtube.com" in parsed.netloc:
            query_params = parse_qs(parsed.query)
            if "v" in query_params:
                video_id = query_params["v"][0]
                if len(video_id) == 11:
                    return video_id
    except Exception:
        pass

    return None


def is_youtube_url(url: str) -> bool:
    """URL이 유효한 YouTube URL인지 확인합니다."""
    return extract_video_id(url) is not None


if __name__ == "__main__":
    # 테스트
    test_urls = [
        "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
        "https://youtu.be/dQw4w9WgXcQ",
        "https://www.youtube.com/embed/dQw4w9WgXcQ",
        "https://www.youtube.com/shorts/dQw4w9WgXcQ",
        "invalid url",
        "https://google.com",
    ]

    for url in test_urls:
        vid = extract_video_id(url)
        print(f"{url[:50]:50} -> {vid}")

```
--- END OF FILE: url_parser.py ---
